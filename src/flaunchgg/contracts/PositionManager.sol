// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import {SafeTransferLib} from '@solady/utils/SafeTransferLib.sol';

import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import {BalanceDelta} from '@uniswap/v4-core/src/types/BalanceDelta.sol';
import {BeforeSwapDelta, BeforeSwapDeltaLibrary, toBeforeSwapDelta} from '@uniswap/v4-core/src/types/BeforeSwapDelta.sol';
import {Currency} from '@uniswap/v4-core/src/types/Currency.sol';
import {Hooks, IHooks} from '@uniswap/v4-core/src/libraries/Hooks.sol';
import {IPoolManager} from '@uniswap/v4-core/src/interfaces/IPoolManager.sol';
import {PoolId, PoolIdLibrary} from '@uniswap/v4-core/src/types/PoolId.sol';
import {PoolKey} from '@uniswap/v4-core/src/types/PoolKey.sol';
import {SafeCast} from '@uniswap/v4-core/src/libraries/SafeCast.sol';
import {StateLibrary} from '@uniswap/v4-core/src/libraries/StateLibrary.sol';

import {BaseHook} from '@uniswap-periphery/base/hooks/BaseHook.sol';

import {BidWall} from '@flaunch/bidwall/BidWall.sol';
import {CurrencySettler} from '@flaunch/libraries/CurrencySettler.sol';
import {FairLaunch} from '@flaunch/hooks/FairLaunch.sol';
import {FeeDistributor} from '@flaunch/hooks/FeeDistributor.sol';
import {FeeExemptions} from '@flaunch/hooks/FeeExemptions.sol';
import {InternalSwapPool} from '@flaunch/hooks/InternalSwapPool.sol';
import {MemecoinFinder} from '@flaunch/types/MemecoinFinder.sol';
import {MemecoinTreasury} from '@flaunch/treasury/MemecoinTreasury.sol';
import {Notifier} from '@flaunch/hooks/Notifier.sol';
import {StoreKeys} from '@flaunch/types/StoreKeys.sol';
import {TreasuryActionManager} from '@flaunch/treasury/ActionManager.sol';

import {IFeeCalculator} from '@flaunch-interfaces/IFeeCalculator.sol';
import {IFlaunch} from '@flaunch-interfaces/IFlaunch.sol';
import {IInitialPrice} from '@flaunch-interfaces/IInitialPrice.sol';
import {IMemecoin} from '@flaunch-interfaces/IMemecoin.sol';


/**
 * The PositionManager is a Uniswap V4 hook that controls the user journey from token creation,
 * to fair launch, to ongoing swaps.
 *
 * The creator of the pool will receive an ERC721 representation of the token. The holder of
 * this token will be the recipient of any creator fees generated by the token in the pool.
 *
 * Hook interactions have aimed to be abstracted into inherited contracts to simplify both
 * functionality and readability. Specific use of each of these contracts has been denoted
 * within comments using square brackets where possible.
 */
contract PositionManager is BaseHook, FeeDistributor, InternalSwapPool, StoreKeys {

    using BeforeSwapDeltaLibrary for BeforeSwapDelta;
    using CurrencySettler for Currency;
    using PoolIdLibrary for PoolKey;
    using SafeCast for uint;
    using StateLibrary for IPoolManager;
    using MemecoinFinder for PoolKey;

    error CallerIsNotBidWall();
    error CannotBeInitializedDirectly();
    error InsufficientFlaunchFee(uint _paid, uint _required);
    error TokenNotFlaunched(uint _flaunchesAt);
    error UnknownPool(PoolId _poolId);

    /// Emitted when a Flaunch pool is created
    event PoolCreated(PoolId indexed _poolId, address _memecoin, address _memecoinTreasury, uint _tokenId, bool _currencyFlipped, uint _flaunchFee, FlaunchParams _params);

    /// Emitted when a Flaunch pool is scheduled
    event PoolScheduled(PoolId indexed _poolId, uint _flaunchesAt);

    /// Emitted when a pool swap occurs
    event PoolSwap(PoolId indexed poolId, int flAmount0, int flAmount1, int flFee0, int flFee1, int ispAmount0, int ispAmount1, int ispFee0, int ispFee1, int uniAmount0, int uniAmount1, int uniFee0, int uniFee1);

    /// Emitted after any transaction to share pool state
    event PoolStateUpdated(PoolId indexed _poolId, uint160 _sqrtPriceX96, int24 _tick, uint24 _protocolFee, uint24 _swapFee, uint128 _liquidity);

    /// Emitted when a user successfully premines their token
    event PoolPremine(PoolId indexed _poolId, int _premineAmount);

    /// Emitted when the `IInitialPrice` contract has been updated
    event InitialPriceUpdated(address _initialPrice);

    /**
     * Defines our constructor parameters.
     *
     * @member nativeToken The native ETH equivalent token used by protocol
     * @member poolManager The Uniswap V4 {PoolManager} contract
     * @member feeDistribution The default fee distribution configuration
     * @member initialPrice Set initial price calculator address
     * @member protocolOwner The EOA that will be the initial owner
     * @member protocolFeeRecipient The recipient EOA of all
     * @member flayGovernance The $FLAY token governance address
     * @member feeExemptions The default global FeeExemption values
     */
    struct ConstructorParams {
        address nativeToken;
        IPoolManager poolManager;
        FeeDistribution feeDistribution;
        IInitialPrice initialPrice;
        address protocolOwner;
        address protocolFeeRecipient;
        address flayGovernance;
        FeeExemptions feeExemptions;
    }

    /**
     * If the creator requests a premine amount of tokens, then these will be cast
     * to this structure.
     *
     * @member amountSpecified The amount of tokens requested to buy as creator
     * @member blockNumber The block that the premine is created and allocated
     */
    struct PoolPremineInfo {
        int amountSpecified;
        uint blockNumber;
    }

    /**
     * Parameters required when flaunching a new token.
     *
     * @member name Name of the token
     * @member symbol Symbol of the token
     * @member tokenUri The generated ERC721 token URI
     * @member initialTokenFairLaunch The amount of tokens to add as single sided fair launch liquidity
     * @member premineAmount The amount of tokens that the creator will buy themselves
     * @member creator The address that will receive the ERC721 ownership and premined ERC20 tokens
     * @member creatorFeeAllocation The percentage of fees the creators wants to take from the BidWall
     * @member flaunchAt The timestamp at which the token will launch
     * @member initialPriceParams The encoded parameters for the Initial Price logic
     * @member feeCalculatorParams The encoded parameters for the fee calculator
     */
    struct FlaunchParams {
        string name;
        string symbol;
        string tokenUri;
        uint initialTokenFairLaunch;
        uint premineAmount;
        address creator;
        uint24 creatorFeeAllocation;
        uint flaunchAt;
        bytes initialPriceParams;
        bytes feeCalculatorParams;
    }

    /// The minimum amount before a distribution is triggered
    uint public constant MIN_DISTRIBUTE_THRESHOLD = 0.001 ether;

    /// The contract that will be used for flaunching tokens
    IFlaunch public flaunchContract;

    /// Our starting token sqrtPriceX96
    IInitialPrice public initialPrice;

    /// Internal storage to allow the `beforeSwap` tick value to be used in `afterSwap`
    int24 internal _beforeSwapTick;

    /// Store the address that will collect protocol fees
    address internal protocolFeeRecipient;

    /// Store the contract that will manage our Bidwall interactions
    BidWall public bidWall;

    /// The contract that handles the FairLaunch flow
    FairLaunch public fairLaunch;

    /// The contract that handles the token Treasury actions
    TreasuryActionManager public actionManager;

    /// Store the contract that will manage fee exemptions
    FeeExemptions public feeExemptions;

    /// Store our {Notifier} contract
    Notifier public notifier;

    /// Store the block timestamp when a poolId is set to launch
    mapping (PoolId _poolId => uint _flaunchTime) public flaunchesAt;

    /// Store the premine information for a pool
    mapping (PoolId _poolId => PoolPremineInfo _premineInfo) public premineInfo;

    /**
     * Initializes our {BaseHook} contract and initializes all implemented hooks.
     */
    constructor (ConstructorParams memory params)
        BaseHook(params.poolManager)
        FeeDistributor(params.nativeToken, params.feeDistribution, params.protocolOwner, params.flayGovernance)
    {
        // Set our contract references
        initialPrice = params.initialPrice;

        // Set our protocol fee recipient
        protocolFeeRecipient = params.protocolFeeRecipient;

        // Register our FeeExemption contract
        feeExemptions = params.feeExemptions;

        // Deploy our BidWall contract and transfer ownership to the protocol owner
        bidWall = new BidWall(params.nativeToken, address(params.poolManager), params.protocolOwner);

        // Deploy our FairLaunch logic
        fairLaunch = new FairLaunch(params.poolManager);

        // Deploy our ActionManager
        actionManager = new TreasuryActionManager(params.protocolOwner);

        // Deploy our notifier
        notifier = new Notifier(params.protocolOwner);

        // Approve the BidWall to manage native token from the PositionManager
        IERC20(params.nativeToken).approve(address(bidWall), type(uint).max);
        IERC20(params.nativeToken).approve(address(fairLaunch), type(uint).max);
    }

    /**
     * Creates a new ERC20 memecoin token creating and an ERC721 that signifies ownership of the
     * flaunched collection. The token is then initialized into a UV4 pool.
     *
     * The FairLaunch period will start in this call, as soon as the pool is initialized.
     *
     * @return memecoin_ The created ERC20 token address
     */
    function flaunch(FlaunchParams calldata _params) external payable returns (address memecoin_) {
        uint tokenId;
        address payable memecoinTreasury;

        // Flaunch our token
        (memecoin_, memecoinTreasury, tokenId) = flaunchContract.flaunch(_params);

        // Check if our pool currency is flipped
        bool currencyFlipped = nativeToken >= memecoin_;

        // Create our Uniswap pool and store the pool key for lookups
        PoolKey memory _poolKey = PoolKey({
            currency0: Currency.wrap(!currencyFlipped ? nativeToken : memecoin_),
            currency1: Currency.wrap(currencyFlipped ? nativeToken : memecoin_),
            fee: 0,
            tickSpacing: 60,
            hooks: IHooks(address(this))
        });

        // Initialize the {MemecoinTreasury} with `PoolKey`
        MemecoinTreasury(memecoinTreasury).initialize(payable(address(this)), address(actionManager), nativeToken, _poolKey);

        // Set the PoolKey to storage
        _poolKeys[memecoin_] = _poolKey;
        PoolId poolId = _poolKey.toId();

        // If we have a non-zero creator fee allocation, then we need to update our creator's
        // fee allocation.
        if (_params.creatorFeeAllocation != 0) {
            creatorFee[poolId] = _params.creatorFeeAllocation;
        }

        {
            // Check if we have a fair launch calculator assigned. If we do, then we want to register
            // any custom parameters that have been passed.
            IFeeCalculator fairLaunchCalculator = getFeeCalculator(true);
            if (address(fairLaunchCalculator) != address(0)) {
                fairLaunchCalculator.setFlaunchParams(poolId, _params.feeCalculatorParams);
            }
        }

        // Initialize our memecoin with the sqrtPriceX96
        int24 initialTick = poolManager.initialize(
            _poolKey,
            initialPrice.getSqrtPriceX96(msg.sender, currencyFlipped, _params.initialPriceParams)
        );

        // Check if we have an initial flaunching fee, check that enough ETH has been sent
        uint flaunchFee = getFlaunchingFee(_params.initialPriceParams);

        emit PoolCreated({
            _poolId: poolId,
            _memecoin: memecoin_,
            _memecoinTreasury: memecoinTreasury,
            _tokenId: tokenId,
            _currencyFlipped: currencyFlipped,
            _flaunchFee: flaunchFee,
            _params: _params
        });

        /**
         * [PREMINE] If the creator has requested tokens from their initial fair launch
         * allocation, which they can purchase in the same transaction.
         */

        if (_params.premineAmount != 0) {
            premineInfo[poolId] = PoolPremineInfo({
                amountSpecified: _params.premineAmount.toInt256(),
                blockNumber: block.number
            });
        }

        /**
         * [FL] At token creation, x% of token supply is put into a one-sided position.
         */

        if (_params.initialTokenFairLaunch != 0) {
            fairLaunch.createPosition(
                poolId,
                initialTick,
                _params.flaunchAt > block.timestamp ? _params.flaunchAt : block.timestamp,
                _params.initialTokenFairLaunch
            );

            // We don't currently require any token approval to create a fair launch position, but
            // when the position closes, the {FairLaunch} contract will supply the {PoolManager}
            // with tokens from this contract.
            IMemecoin(memecoin_).approve(address(fairLaunch), type(uint).max);
        }

        /**
         * [SCHEDULE] If we have a timestamp in the future, then we set our schedule mapping.
         */

        if (_params.flaunchAt > block.timestamp) {
            flaunchesAt[poolId] = _params.flaunchAt;
            emit PoolScheduled(poolId, _params.flaunchAt);
        } else {
            // If the `flaunchAt` timestamp has already passed, then use the current timestamp
            flaunchesAt[poolId] = block.timestamp;
        }

        // Refund any additional ETH
        if (flaunchFee != 0) {
            // Check if we have insufficient value provided
            if (msg.value < flaunchFee) {
                revert InsufficientFlaunchFee(msg.value, flaunchFee);
            }

            // Pay the flaunching fee to our fee recipient
            SafeTransferLib.safeTransferETH(protocolFeeRecipient, flaunchFee);
        }

        // Refund any ETH that was not required
        if (msg.value > flaunchFee) {
            SafeTransferLib.safeTransferETH(msg.sender, msg.value - flaunchFee);
        }

        // After our contract is initialized, we mark our pool as initialized and emit
        // our state update to notify the UX of current prices, etc. This will include
        // optional liquidity modifications from the Fair Launch logic.
        _emitPoolStateUpdate(poolId, IHooks.afterInitialize.selector, abi.encode(tokenId, _params));
    }

    /**
     * Returns the PoolKey mapped to the token address. If none is set then a zero value
     * will be returned for the fields.
     *
     * @dev The easiest way to check for an empty response is `tickSpacing = 0`
     *
     * @param _token The address of the ERC20 token
     *
     * @return The corresponding {PoolKey} for the token
     */
    function poolKey(address _token) external view returns (PoolKey memory) {
        return _poolKeys[_token];
    }

    /**
     * Defines the Uniswap V4 hooks that are used by our implementation. This will determine
     * the address that our contract **must** be deployed to for Uniswap V4. This address suffix
     * is shown in the dev comments for this function call.
     *
     * @dev 1011 1111 0111 00 == 2FDC
     */
    function getHookPermissions() public pure override returns (Hooks.Permissions memory) {
        return Hooks.Permissions({
            beforeInitialize: true, // Prevent initialize
            afterInitialize: false,
            beforeAddLiquidity: true, // [FairLaunch], [InternalSwapPool]
            afterAddLiquidity: true, // [EventTracking]
            beforeRemoveLiquidity: true, // FairLaunch], [InternalSwapPool]
            afterRemoveLiquidity: true, // [EventTracking]
            beforeSwap: true, // FairLaunch], [InternalSwapPool]
            afterSwap: true, // [FeeDistributor], [InternalSwapPool], [BidWall], [EventTracking]
            beforeDonate: false,
            afterDonate: true, // [EventTracking]
            beforeSwapReturnDelta: true, // [InternalSwapPool]
            afterSwapReturnDelta: true, // [FeeDistributor]
            afterAddLiquidityReturnDelta: false,
            afterRemoveLiquidityReturnDelta: false
        });
    }

    /**
     * The hook called before the state of a pool is initialized. Prevents external contracts
     * from initializing pools using our contract as a hook.
     *
     * @dev As we call `poolManager.initialize` from the IHooks contract itself, we bypass this
     * hook call as therefore bypass the prevention.
     */
    function beforeInitialize(address, PoolKey calldata, uint160) external view override onlyPoolManager returns (bytes4) {
        revert CannotBeInitializedDirectly();
    }

    /**
     * [FL] Handles swaps during the FairLaunch and closure of the position when it expires
     * [ISP] Checks if we can process an internal swap ahead of the Uniswap swap.
     * [FD] Captures fees from the internal swap pool
     *
     * @param _sender The address calling the swap
     * @param _key The key for the pool
     * @param _params The parameters for the swap
     * @param _hookData Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook
     *
     * @return selector_ The function selector for the hook
     * @return beforeSwapDelta_ The hook's delta in specified and unspecified currencies. Positive: the hook is owed/took currency, negative: the hook owes/sent currency
     * @return swapFee_ The percentage fee applied to our swap
     */
    function beforeSwap(
        address _sender,
        PoolKey calldata _key,
        IPoolManager.SwapParams memory _params,
        bytes calldata _hookData
    ) public override onlyPoolManager returns (
        bytes4 selector_,
        BeforeSwapDelta beforeSwapDelta_,
        uint24
    ) {
        /**
         * [SCHEDULE][PREMINE] Check if the token is scheduled to be flaunched and only
         * allow a swap to take place if there is a premine call available.
         */

        {
            PoolId poolId = _key.toId();

            // If set, get the timestamp that the pool is scheduled to flaunch
            uint _flaunchesAt = flaunchesAt[poolId];
            if (_flaunchesAt != 0) {
                // If we have a schedule set for the token, then we need to make an additional
                // check to see if a premine is set, and if it's valid.
                PoolPremineInfo storage _premineInfo = premineInfo[poolId];

                // The validity of a premine ensures that we are in the same block and that the
                // amount specified is the same. We cannot check that the caller is the same as
                // the `_sender` is obfuscated to be the swap contract.
                if (_premineInfo.blockNumber == block.number && _params.amountSpecified == _premineInfo.amountSpecified) {
                    emit PoolPremine(poolId, _premineInfo.amountSpecified);
                    _premineInfo.blockNumber = 0;
                } else {
                    // If the timestamp has not yet passed, then we revert
                    if (_flaunchesAt > block.timestamp) {
                        revert TokenNotFlaunched(_flaunchesAt);
                    }

                    // Remove the schedule timestamp to prevent future checks
                    delete flaunchesAt[poolId];
                }
            }
        }

        // Check if our fair launch period hasn't ended and already been processed
        FairLaunch.FairLaunchInfo memory fairLaunchInfo = fairLaunch.fairLaunchInfo(_key.toId());
        if (!fairLaunchInfo.closed) {
            PoolId poolId = _key.toId();
            bool nativeIsZero = nativeToken == Currency.unwrap(_key.currency0);

            /**
             * [FL] If the FairLaunch window has ended, but our position is still open, then we
             * need to close the position.
             */

            if (!fairLaunch.inFairLaunchWindow(poolId)) {
                fairLaunch.closePosition({
                    _poolKey: _key,
                    _tokenFees: _poolFees[poolId].amount1,
                    _nativeIsZero: nativeIsZero
                });
            }
            else {

                /**
                 * [FL] If we are still in the FairLaunch window, then we need to prevent any swaps that
                 * are specified to sell the {Memecoin}.
                 */

                if (nativeIsZero != _params.zeroForOne) {
                    revert FairLaunch.CannotSellTokenDuringFairLaunch();
                }

                /**
                 * [FL] We attempt to fill the swap request from our FairLaunch position. If the
                 * swap parameters surpass the FairLaunch position, or the window has closed since
                 * the last swap, then this call will also close the position and create our new
                 * range.
                 */

                // Try to fill from FL at specific tick
                BalanceDelta fairLaunchFillDelta;
                (beforeSwapDelta_, fairLaunchFillDelta, fairLaunchInfo) = fairLaunch.fillFromPosition(_key, _params.amountSpecified, nativeIsZero);

                // Give the tokens to Uniswap V4 so that it can play good-cop and give them to the user
                _settleDelta(_key, fairLaunchFillDelta);

                /**
                 * [FD] We need to determine the amount of fees generated by our fair launch swap to
                 * capture, rather than sending the full amount to the end user.
                 */

                // We need to capture fees from our internal swap at this point
                uint swapFee = _captureAndDepositFees(_key, _params, _sender, beforeSwapDelta_.getUnspecifiedDelta(), _hookData);

                // Increment our swap
                _captureDelta(_params, TS_FL_AMOUNT0, TS_FL_AMOUNT1, beforeSwapDelta_);
                _captureDeltaSwapFee(_params, TS_FL_FEE0, TS_FL_FEE1, swapFee);

                // Increase the delta being sent back
                beforeSwapDelta_ = toBeforeSwapDelta(
                    beforeSwapDelta_.getSpecifiedDelta(),
                    beforeSwapDelta_.getUnspecifiedDelta() + swapFee.toInt128()
                );

                // A FairLaunch transaction will always facilitate purchasing Memecoin with
                // Native Token. This means that if the `amountSpecified` not negative, then we will
                // have captured the fee in Native Token and as such we need to reduce the amount of
                // revenue that we record.
                if (_params.amountSpecified >= 0 && swapFee != 0) {
                    fairLaunch.modifyRevenue(poolId, -swapFee.toInt128());
                }

                // If we have run out of tokens, then we can close the pool
                if (fairLaunchInfo.supply == 0) {
                    fairLaunch.closePosition({
                        _poolKey: _key,
                        _tokenFees: _poolFees[poolId].amount1,
                        _nativeIsZero: nativeIsZero
                    });
                }
            }
        }

        /**
         * [ISP] We want to see if we have any token1 fee tokens that we can use to fill the swap
         * before it hits the Uniswap pool. This prevents the pool from being affected and reduced
         * gas costs. This also allows us to benefit from the Uniswap routing infrastructure.
         *
         * This frontruns Uniswap to sell undesired token amounts from our fees into desired tokens
         * ahead of our fee distribution. This acts as a partial orderbook to remove impact against
         * our pool.
         */

        (uint tokenIn, uint tokenOut) = _internalSwap(poolManager, _key, _params, nativeToken == Currency.unwrap(_key.currency0));
        if (tokenIn + tokenOut != 0) {
            // Update our hook delta to reduce the upcoming swap amount to show that we have
            // already spent some of the ETH and received some of the underlying ERC20.
            BeforeSwapDelta internalBeforeSwapDelta = _params.amountSpecified >= 0
                ? toBeforeSwapDelta(-tokenOut.toInt128(), tokenIn.toInt128())
                : toBeforeSwapDelta(tokenIn.toInt128(), -tokenOut.toInt128());

            /**
             * [FD] We need to determine the amount of fees generated by our internal swap to capture,
             * rather than sending the full amount to the end user.
             */

            // We need to capture fees from our internal swap at this point
            uint swapFee = _captureAndDepositFees(_key, _params, _sender, internalBeforeSwapDelta.getUnspecifiedDelta(), _hookData);

            // Increment our swap
            _captureDelta(_params, TS_ISP_AMOUNT0, TS_ISP_AMOUNT1, internalBeforeSwapDelta);
            _captureDeltaSwapFee(_params, TS_ISP_FEE0, TS_ISP_FEE1, swapFee);

            // Increase the delta being sent back
            beforeSwapDelta_ = toBeforeSwapDelta(
                beforeSwapDelta_.getSpecifiedDelta() + internalBeforeSwapDelta.getSpecifiedDelta(),
                beforeSwapDelta_.getUnspecifiedDelta() + internalBeforeSwapDelta.getUnspecifiedDelta() + swapFee.toInt128()
            );
        }

        // Capture the beforeSwap tick value before actioning our Uniswap swap
        (, _beforeSwapTick,,) = poolManager.getSlot0(_key.toId());

        // Set our return selector
        selector_ = IHooks.beforeSwap.selector;
    }

    /**
     * [FD] Captures fees from the swap to either distribute or send to ISP
     * [ISP] Once a swap has been made, we distribute fees to our LPs and emit our price update event.
     * [FD] Tracks the swap for future fee calculations
     * [FL][BW] If Fair Launch ended then we may have an ETH to deposit into the BidWall
     *
     * @param _sender The sender (or swap contract) making the call
     * @param _key The key for the pool
     * @param _params The parameters for the swap
     * @param _delta The amount owed to the caller (positive) or owed to the pool (negative)
     * @param _hookData Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook
     *
     * @return selector_ The function selector for the hook
     * @return hookDeltaUnspecified_ The hook's delta in unspecified currency. Positive: the hook is owed/took currency, negative: the hook owes/sent currency
     */
    function afterSwap(
        address _sender,
        PoolKey calldata _key,
        IPoolManager.SwapParams calldata _params,
        BalanceDelta _delta,
        bytes calldata _hookData
    ) public override onlyPoolManager returns (
        bytes4 selector_,
        int128 hookDeltaUnspecified_
    ) {
        /**
         * [FD] We need to determine the amount of fees generated by our Uniswap swap to capture,
         * rather than sending the full amount to the end user.
         */

        // Determine the currency that we will be taking our fee from
        (int128 amount0, int128 amount1) = (_delta.amount0(), _delta.amount1());
        int128 swapAmount = _params.amountSpecified < 0 == _params.zeroForOne ? amount1 : amount0;

        // Capture the swap fees and dispatch the referrer's share if set
        uint swapFee = _captureAndDepositFees(_key, _params, _sender, swapAmount, _hookData);

        // Increment our swap
        assembly {
            tstore(TS_UNI_AMOUNT0, amount0)
            tstore(TS_UNI_AMOUNT1, amount1)
        }

        _captureDeltaSwapFee(_params, TS_UNI_FEE0, TS_UNI_FEE1, swapFee);

        /**
         * [ISP] Distribute any fees that have been converted by the swap.
         */

        _distributeFees(_key);

        /**
         * [FD] If we have a feeCalculator, then we want to track the swap data for any
         * dynamic calculations.
         */

        PoolId poolId = _key.toId();

        {
            IFeeCalculator _feeCalculator = getFeeCalculator(fairLaunch.inFairLaunchWindow(poolId));
            if (address(_feeCalculator) != address(0)) {
                _feeCalculator.trackSwap(_sender, _key, _params, _delta, _hookData);
            }
        }

        // Set our return selector
        hookDeltaUnspecified_ = swapFee.toInt128();

        selector_ = IHooks.afterSwap.selector;

        // Emit our compiled swap data
        _emitSwapUpdate(poolId);

        // Emit our pool state update to listeners
        _emitPoolStateUpdate(poolId, selector_, abi.encode(_sender, _params, _delta));
    }

    /**
     * [FL] Prevent liquidity modification during FairLaunch period
     * [FD] Before a liquidity position is modified, we distribute fees before they can
     * come in to take a share of fees that they have not earned.
     *
     * @param _key The key for the pool
     *
     * @return selector_ The function selector for the hook
     */
    function beforeAddLiquidity(
        address _sender,
        PoolKey calldata _key,
        IPoolManager.ModifyLiquidityParams calldata,
        bytes calldata
    ) public view override onlyPoolManager returns (
        bytes4 selector_
    ) {
        // [FL] If in fair launch window, we need to prevent liquidity being added
        _canModifyLiquidity(_key.toId(), _sender);

        selector_ = IHooks.beforeAddLiquidity.selector;
    }

    /**
     * Once a liquidity has been added, we emit our price update event.
     *
     * @param _sender The initial msg.sender for the add liquidity call
     * @param _key The key for the pool
     * @param _delta The caller's balance delta after adding liquidity; the sum of principal delta, fees accrued, and hook delta
     * @param _feesAccrued The fees accrued since the last time fees were collected from this position
     *
     * @return selector_ The function selector for the hook
     * @return BalanceDelta The hook's delta in token0 and token1. Positive: the hook is owed/took currency, negative: the hook owes/sent currency
     */
    function afterAddLiquidity(
        address _sender,
        PoolKey calldata _key,
        IPoolManager.ModifyLiquidityParams calldata,
        BalanceDelta _delta,
        BalanceDelta _feesAccrued,
        bytes calldata
    ) external override onlyPoolManager returns (
        bytes4 selector_,
        BalanceDelta
    ) {
        selector_ = IHooks.afterAddLiquidity.selector;

        // Emit our pool state update to listeners
        _emitPoolStateUpdate(_key.toId(), selector_, abi.encode(_sender, _delta, _feesAccrued));
    }

    /**
     * [FL] Prevent liquidity modification during FairLaunch period
     * [FD] Before liquidity is removed, we distribute fees.
     *
     * @param _key The key for the pool
     *
     * @return selector_ The function selector for the hook
     */
    function beforeRemoveLiquidity(
        address _sender,
        PoolKey calldata _key,
        IPoolManager.ModifyLiquidityParams calldata,
        bytes calldata
    ) public view override onlyPoolManager returns (
        bytes4 selector_
    ) {
        // [FL] If in fair launch window, we need to prevent liquidity being removed
        _canModifyLiquidity(_key.toId(), _sender);

        // Set our return selector
        selector_ = IHooks.beforeRemoveLiquidity.selector;
    }

    /**
     * Once liquidity has been removed, we emit our price update event.
     *
     * @param _sender The initial msg.sender for the remove liquidity call
     * @param _key The key for the pool
     * @param _delta The caller's balance delta after removing liquidity; the sum of principal delta, fees accrued, and hook delta
     * @param _feesAccrued The fees accrued since the last time fees were collected from this position
     *
     * @return selector_ The function selector for the hook
     */
    function afterRemoveLiquidity(
        address _sender,
        PoolKey calldata _key,
        IPoolManager.ModifyLiquidityParams calldata,
        BalanceDelta _delta,
        BalanceDelta _feesAccrued,
        bytes calldata
    ) public override onlyPoolManager returns (bytes4 selector_, BalanceDelta) {
        selector_ = IHooks.afterRemoveLiquidity.selector;

        // Emit our pool state update to listeners
        _emitPoolStateUpdate(_key.toId(), selector_, abi.encode(_sender, _delta, _feesAccrued));
    }

    /**
     * The hook called after donate, emitting our price update event.
     *
     * @param _sender The initial msg.sender for the donate call
     * @param _key The key for the pool
     * @param _amount0 The amount of token0 being donated
     * @param _amount1 The amount of token1 being donated
     *
     * @return selector_ The function selector for the hook
     */
    function afterDonate(address _sender, PoolKey calldata _key, uint _amount0, uint _amount1, bytes calldata) external override onlyPoolManager returns (bytes4 selector_) {
        selector_ = IHooks.afterDonate.selector;

        // Emit our pool state update to listeners
        _emitPoolStateUpdate(_key.toId(), selector_, abi.encode(_sender, _amount0, _amount1));
    }

    /**
     * Gets the ETH fee that must be paid to flaunch a token.
     *
     * @return The ETH value of the fee
     */
    function getFlaunchingFee(bytes calldata _initialPriceParams) public view returns (uint) {
        return initialPrice.getFlaunchingFee(msg.sender, _initialPriceParams);
    }

    /**
     * Gets the ETH market cap for a new token that will be flaunched.
     *
     * @return The ETH market cap value
     */
    function getFlaunchingMarketCap(bytes calldata _initialPriceParams) public view returns (uint) {
        return initialPrice.getMarketCap(_initialPriceParams);
    }

    /**
     * Allows the contract used to flaunch a new token to be updated.
     *
     * @param _flaunchContract The new {IFlaunch} contract address
     */
    function setFlaunch(address _flaunchContract) public onlyOwner {
        flaunchContract = IFlaunch(_flaunchContract);
    }

    /**
     * Updates the `IInitialPrice` contract address that is used during `flaunch` to calculate
     * the initial tick / sqrtPriceX96 value.
     *
     * @param _initialPrice The contract address for the `IInitialPrice` contract
     */
    function setInitialPrice(address _initialPrice) public onlyOwner {
        initialPrice = IInitialPrice(_initialPrice);
        emit InitialPriceUpdated(_initialPrice);
    }

    /**
     * Calls for the BidWall to be closed, as this requires callback from the {PoolManager}.
     */
    function closeBidWall(PoolKey memory _key) public {
        // Ensure that the call is made by the BidWall which validates logic
        if (msg.sender != address(bidWall)) revert CallerIsNotBidWall();

        // Ensure that the PoolKey that is being closed is valid and recognised on the protocol,
        // otherwise we could processing issues and false positives in upcoming steps. We need to
        // ensure that the PoolKey is recognised (by checking the hooks address is not zero) and
        // that the PoolId matches when encoded.
        PoolKey memory storedKey = _poolKeys[address(_key.memecoin(nativeToken))];
        if (storedKey.hooks == IHooks(address(0)) || PoolId.unwrap(storedKey.toId()) != PoolId.unwrap(_key.toId())) {
            revert UnknownPool(_key.toId());
        }

        // Action our BidWall closure via the {PoolManager} unlock
        poolManager.unlock(abi.encode(_key));
    }

    /**
     * This function should only be called by the `closeBidWall` function to unlock the {PoolManager}
     * interactions for the `{BidWall}.closeBidWall` function.
     *
     * @param _data The encoded {PoolKey} for the `closeBidWall` request
     *
     * @return bytes Empty data; nothing will be returned
     */
    function _unlockCallback(bytes calldata _data) internal override returns (bytes memory) {
        bidWall.closeBidWall(abi.decode(_data, (PoolKey)));
    }

    /**
     * Capture the fees from our swap. This could either be from an internal swap (`beforeSwap`)
     * or from the actual Uniswap swap (`afterSwap`).
     *
     * @dev This is only used due to too many variables in the `beforeSwap` function
     *
     * @param _key The {PoolKey} that the swap was made against
     * @param _params The swap parameters called in the swap
     * @param _sender The sender of the swap call
     * @param _delta The balance change from the swap
     * @param _hookData Additional bytes data passed in the swap
     *
     * @return swapFee_ The fee taken from the swap
     */
    function _captureAndDepositFees(
        PoolKey calldata _key,
        IPoolManager.SwapParams memory _params,
        address _sender,
        int128 _delta,
        bytes calldata _hookData
    ) internal returns (uint swapFee_) {
        // Determine the swap fee currency based on swap parameters
        Currency swapFeeCurrency = _params.amountSpecified < 0 == _params.zeroForOne ? _key.currency1 : _key.currency0;

        // Capture our swap fees amount
        swapFee_ = _captureSwapFees({
            _poolManager: poolManager,
            _key: _key,
            _params: _params,
            _feeCalculator: getFeeCalculator(fairLaunch.inFairLaunchWindow(_key.toId())),
            _swapFeeCurrency: swapFeeCurrency,
            _swapAmount: uint128(_delta < 0 ? -_delta : _delta),
            _feeExemption: feeExemptions.feeExemption(_sender)
        });

        // If we have no swap fees, then we have nothing to process
        if (swapFee_ == 0) {
            return swapFee_;
        }

        // Check if we have a referrer set and send them the currency directly
        uint referrerFee = _distributeReferrerFees({
            _key: _key,
            _swapFeeCurrency: swapFeeCurrency,
            _swapFee: swapFee_,
            _hookData: _hookData
        });

        // Deposit the remaining fees against our pool to be either distributed to
        // others, or placed into the Internal Swap Pool to be converted into an ETH
        // equivalent token. We don't reduce the amount by referrer fees as we still
        // need to claim this from the PoolManager.
        _depositFees(
            _key,
            Currency.unwrap(swapFeeCurrency) == nativeToken ? swapFee_ - referrerFee : 0,
            Currency.unwrap(swapFeeCurrency) == nativeToken ? 0 : swapFee_ - referrerFee
        );
    }

    /**
     * We want to be able to distribute fees across our {FeeDistribution} recipients
     * when we reach a set threshold. This will only ever distribute the ETH equivalent
     * token, as the non-ETH token will be converted via the {InternalSwapPool} hook logic.
     *
     * @dev There referrer has already received their share, so they do not need to be
     * taken into account at this point.
     *
     * @param _poolKey The PoolKey reference that will have fees distributed
     */
    function _distributeFees(PoolKey memory _poolKey) internal {
        PoolId poolId = _poolKey.toId();

        // Get the amount of the native token available to distribute
        uint distributeAmount = _poolFees[poolId].amount0;

        // Ensure that the collection has sufficient fees available
        if (distributeAmount < MIN_DISTRIBUTE_THRESHOLD) return;

        // Reduce our available fees for the pool
        _poolFees[poolId].amount0 = 0;

        // Find the distribution amount across our different users. The amount that treasury
        // receives will be determined by variables throughout the distribution flow, such as
        // the BidWall being disabled, etc.
        (uint bidWallFee, uint creatorFee, uint protocolFee) = feeSplit(poolId, distributeAmount);
        uint treasuryFee;

        // Load our memecoin so that we can query the creator and treasury
        IMemecoin memecoin = _poolKey.memecoin(nativeToken);

        // Check if our creator has been burned, as this changes fee allocation in a number of places
        address poolCreator = memecoin.creator();
        bool poolCreatorBurned = poolCreator == address(0);

        if (creatorFee != 0) {
            // Ensure that the pool creator has not burned their ownership and send them the fees
            if (!poolCreatorBurned) {
                _allocateFees(poolId, poolCreator, creatorFee);
            }
            // If the pool creator has burned their ownership, then we instead send fees directly
            // to the BidWall.
            else {
                bidWallFee += creatorFee;
                creatorFee = 0;
            }
        }

        if (bidWallFee != 0) {
            // Check if we have an active BidWall for the pool. If we don't have an active BidWall, then
            // we will need to instead allocate this to the protocol. If we are still in the FairLaunch
            // window the this will just carry over into the FairLaunch created position, so we already
            // have this value attributed.
            if (bidWall.isBidWallEnabled(poolId) && !fairLaunch.inFairLaunchWindow(poolId)) {
                // Otherwise, we can deposit directly into the BidWall as we have permission to modify
                // liquidity outside of the window.
                bidWall.deposit(_poolKey, bidWallFee, _beforeSwapTick, nativeToken == Currency.unwrap(_poolKey.currency0));
            } else {
                // If we cannot import into BidWall, then treasury will be allocated the fees
                treasuryFee += bidWallFee;
                bidWallFee = 0;
            }
        }

        if (treasuryFee != 0) {
            // Ensure that the pool creator has not burned their ownership and send treasury the fees
            if (!poolCreatorBurned) {
                _allocateFees(poolId, memecoin.treasury(), treasuryFee);
            } else {
                // If we cannot allocate to treasury, then protocol receives the fees
                protocolFee += treasuryFee;
                treasuryFee = 0;
            }
        }

        // Finally we allocate our protocol fees
        if (protocolFee != 0) {
            _allocateFees(poolId, protocolFeeRecipient, protocolFee);
        }

        emit PoolFeesDistributed(poolId, distributeAmount, creatorFee, bidWallFee, treasuryFee, protocolFee);
    }

    /**
     * Using the `tstore` values that we have generated along the way, we emit an event that shows
     * the breakdown of fees earned at each swap point.
     *
     * @param _poolId The PoolId that is being emitted
     */
    function _emitSwapUpdate(PoolId _poolId) internal {
        emit PoolSwap(
            _poolId,
            _tload(TS_FL_AMOUNT0), _tload(TS_FL_AMOUNT1), _tload(TS_FL_FEE0), _tload(TS_FL_FEE1),
            _tload(TS_ISP_AMOUNT0), _tload(TS_ISP_AMOUNT1), _tload(TS_ISP_FEE0), _tload(TS_ISP_FEE1),
            _tload(TS_UNI_AMOUNT0), _tload(TS_UNI_AMOUNT1), _tload(TS_UNI_FEE0), _tload(TS_UNI_FEE1)
        );

        // @dev We flush the tstore values at this point as although they are only set
        // explicitly and not modified, both the FL and ISP could be bypassed but the tstore
        // data would remain.

        assembly {
            tstore(TS_FL_AMOUNT0, 0)
            tstore(TS_FL_AMOUNT1, 0)
            tstore(TS_FL_FEE0, 0)
            tstore(TS_FL_FEE1, 0)
            tstore(TS_ISP_AMOUNT0, 0)
            tstore(TS_ISP_AMOUNT1, 0)
            tstore(TS_ISP_FEE0, 0)
            tstore(TS_ISP_FEE1, 0)
            tstore(TS_UNI_AMOUNT0, 0)
            tstore(TS_UNI_AMOUNT1, 0)
            tstore(TS_UNI_FEE0, 0)
            tstore(TS_UNI_FEE1, 0)
        }
    }

    /**
     * Emits an event that provides pool state updates and passes the data to subscribers.
     *
     * @param _poolId The PoolId that has been updated
     * @param _key The selector being sent to notification subscribers
     * @param _data The data being sent to notification subscribers
     */
    function _emitPoolStateUpdate(PoolId _poolId, bytes4 _key, bytes memory _data) internal {
        // Notify our subscribed contracts
        notifier.notifySubscribers(_poolId, _key, _data);

        // Emit our event
        (uint160 sqrtPriceX96, int24 tick, uint24 protocolFee, uint24 swapFee) = poolManager.getSlot0(_poolId);
        emit PoolStateUpdated(_poolId, sqrtPriceX96, tick, protocolFee, swapFee, poolManager.getLiquidity(_poolId));
    }

    /**
     * Settles tokens against the PoolManager based on the BalanceDelta passed.
     *
     * @dev This is required to be separated due to Stack Too Deep errors
     *
     * @param _poolKey The pool key to settle against
     * @param _delta The BalanceDelta showing token amounts to settle
     */
    function _settleDelta(PoolKey memory _poolKey, BalanceDelta _delta) internal {
        if (_delta.amount0() < 0) {
            _poolKey.currency0.settle(poolManager, address(this), uint(-int(_delta.amount0())), false);
        } else if (_delta.amount0() > 0) {
            poolManager.take(_poolKey.currency0, address(this), uint(int(_delta.amount0())));
        }

        if (_delta.amount1() < 0) {
            _poolKey.currency1.settle(poolManager, address(this), uint(-int(_delta.amount1())), false);
        } else if (_delta.amount1() > 0) {
            poolManager.take(_poolKey.currency1, address(this), uint(int(_delta.amount1())));
        }
    }

    /**
     * We need to be able to set the (un)specified token to amount0 / amount1 for the expected
     * event emit format.
     *
     * @param _params The `SwapParams` used to capture the delta
     * @param _key_amount0 The tstore key for the token0 amount
     * @param _key_amount1 The tstore key for the token1 amount
     * @param _delta The `BeforeSwapDelta` that is being captured
     */
    function _captureDelta(
        IPoolManager.SwapParams memory _params,
        bytes32 _key_amount0,
        bytes32 _key_amount1,
        BeforeSwapDelta _delta
    ) internal {
        (int token0, int token1) = _params.amountSpecified < 0 == _params.zeroForOne
            ? (-_delta.getSpecifiedDelta(), -_delta.getUnspecifiedDelta())
            : (-_delta.getUnspecifiedDelta(), -_delta.getSpecifiedDelta());

        // Store our amounts
        assembly {
            tstore(_key_amount0, token0)
            tstore(_key_amount1, token1)
        }
    }

    /**
     * Maps our swap fee to the expected event emit format.
     *
     * @param _params The `SwapParams` used to capture the delta
     * @param _key_fee0 The tstore key for the token0 fee amount
     * @param _key_fee1 The tstore key for the token1 fee amount
     * @param _delta The `uint` that is being captured for the fee
     */
    function _captureDeltaSwapFee(
        IPoolManager.SwapParams memory _params,
        bytes32 _key_fee0,
        bytes32 _key_fee1,
        uint _delta
    ) internal {
        // The delta provided needs to be made negative
        int delta = -int(_delta);

        if (_params.amountSpecified < 0 == _params.zeroForOne) {
            assembly {
                tstore(_key_fee0, 0)
                tstore(_key_fee1, delta)
            }
        } else {
            assembly {
                tstore(_key_fee0, delta)
                tstore(_key_fee1, 0)
            }
        }
    }

    /**
     * If in fair launch window, we need to prevent liquidity being added. We can, however, modify
     * liquidity if we are making the call from the BidWall or FairLaunch contracts.
     *
     * @param _poolId The PoolId having the liquidity modified
     * @param _sender The address that is trying to modify liquidity
     */
    function _canModifyLiquidity(PoolId _poolId, address _sender) internal view {
        // Check our valid addresses
        if (_sender == address(bidWall) || _sender == address(fairLaunch)) {
            return;
        }

        // Check if we have exited the FairLaunch window
        if (!fairLaunch.inFairLaunchWindow(_poolId)) {
            return;
        }

        // All other scenarios will result in revert
        revert FairLaunch.CannotModifyLiquidityDuringFairLaunch();
    }

    /**
     * Helper function to allow for tstore-d variables to be called individually. This saves us
     * defining an additional variable before our `tload` calls inside the function.
     *
     * @param _key The `tstore` key to load
     *
     * @return value_ The `int` value in the tstore
     */
    function _tload(bytes32 _key) internal view returns (int value_) {
        assembly { value_ := tload(_key) }
    }

    /**
     * Override to return true to make `_initializeOwner` prevent double-initialization.
     *
     * @return bool Set to `true` to prevent owner being reinitialized.
     */
    function _guardInitializeOwner() internal pure override returns (bool) {
        return true;
    }

}
