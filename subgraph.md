# Subgraph Planning

_Note: This is a WIP document and may currently be out of date_

All of the following will be held or generated by the `PositionManager.sol` contract. The subheadings
used in this document are more for categorisation and internal file structure.


## Constants

```solidity
/// The minimum amount before a distribution is triggered
uint internal constant DONATE_THRESHOLD_MIN = 0.001 ether;

/// Defines our tick range based on 60 `tickSpacing`
int24 internal constant MIN_TICK = -887220;
int24 internal constant MAX_TICK = 887220;

/// The static fee amount to charge until fair launch window closes (1% with 4dp)
uint24 internal constant FAIR_LAUNCH_SWAP_FEE = 1_0000;

/// Our fair launch window duration
uint public constant FAIR_LAUNCH_WINDOW = 1 hours;

/// Our tick width
int24 constant PBW_TICK_WIDTH = 60;
```


## Structures

### Global Config

```solidity
Config {

  /// Checks if the protocol is paused. This is triggered by `Paused(address sender)` and
  /// `Unpaused(address sender)`.
  bool paused;

  /// References the {FeeCalculator} contract used, and is updated when
  /// `FeeCalculatorUpdated(address _feeCalculator)` is emitted.
  address feeCalculator;

  /// Our global FeeDistribution data
  FeeDistribution feeDistribution;

}
```


### BidWall

Each pool created will have a bidwall. This won't be defined when the pool is first created but instead
when the bidwall first reaches it's first threshold.

```solidity
BidWall {

  event BidWallInitialized(PoolId _poolId, uint _eth, int24 _tickLower, int24 _tickUpper);
  event BidWallRepositioned(PoolId _poolId, uint _eth, int24 _tickLower, int24 _tickUpper);
  event BidWallClosed(PoolId _poolId, address _recipient, uint _eth);

  /// Will be first set by `BidWallInitialized`
  bytes32 id (poolId);

  /// Enabled by `BidWallInitialized` and disabled by `BidWallClosed`
  bool initialized;

  /// Bidwall tick range updated by `BidWallInitialized` and `BidWallRepositioned`
  int24 tickLower;
  int24 tickUpper;

  /// Amount deposited in the BidWall. This will be cumulative.
  uint amount;

}
```

```solidity
BidWallDistribution {

  event BidWallRewardsTransferred(PoolId _poolId, address _recipient, uint _tokens);
  event BidWallClosed(PoolId _poolId, address _recipient, uint _eth);

  bytes32 id (poolId);

  address token;
  uint amount;

}
```


### Fair Launch

For the first _x_ amount of time, we will have fixed fees (defined by `FAIR_LAUNCH_SWAP_FEE`) and the
user will only be able to buy tokens. The token price will also be in a single tick for a fixed price.

This will be initialized at the same point as a pool (`FairLaunchStarted`).

```solidity
FairLaunch {

  event FairLaunchEnded(PoolId _poolId, int24 _tickLower, int24 _tickUpper, uint _tokenSupply, uint _endedAt);

  bytes32 id (poolId);

  /// Enabled by `FairLaunchStarted` and disabled by `FairLaunchEnded`
  bool active;

  /// Set by `FairLaunchStarted`
  int24 tick;
  uint initialSupply;

  /// Set by `FairLaunchEnded` by taking the `_ethEarned` and `_tokensRemaining`
  uint ethEarned;
  uint unsoldInitialSupply;

  /// Capture the `starts_at` timestamp from when the `FairLaunchStarted` event is emitted, and
  /// the `ends_at` timestamp from the start time plus the `FAIR_LAUNCH_WINDOW` timestamp.
  uint starts_at;
  uint ends_at;

}
```


### Fee Distribution

This is set globally, but will also need the ability to be set per-pool. These fees work like a waterfall,
with the swap fee being taken from the overall tx, then the referrer taking their percent, protocol, creator
and then finally bid wall. For this reason it doesn't need to all equal 100%, as one level could take 50%
and then the next can take 75% of the remaining 50%, etc.

```solidity
FeeDistribution {

  event FeeDistributionUpdated(FeeDistribution _feeDistribution);
  event CreatorFeeAllocationUpdated(PoolId _poolId, uint24 _allocation);

  // Set by `FeeDistributionUpdated`
  uint24 swapFee;
  uint24 referrer;
  uint24 protocol;
  bool active;

  // Set by `CreatorFeeAllocationUpdated`
  uint24 creator;

}
```


### Fee Exemptions

If a user has a varied fee rate for their EOA, then they will have a record in this. They will have
this same reduced fee for all pools.

```solidity
FeeExemption {

  event BeneficiaryFeeSet(address _beneficiary, uint24 _flatFee);
  event BeneficiaryFeeRemoved(address _beneficiary);

  address beneficiary; // Key
  uint24 flatFee;

}
```


### Pool

```solidity
Pool {

  event PoolCreated(PoolId _poolId, uint _initialTokenFairLaunch, uint _fairLaunchEnds, address _memecoin, address _memecoinTreasury, address _creator);
  event PoolStateUpdated(PoolId _poolId, uint160 _sqrtPriceX96, int24 _tick, uint24 _protocolFee, uint24 _swapFee, uint128 _liquidity);

  event FeeDistributionUpdated(FeeDistribution _feeDistribution);
  event PoolFeeDistributionUpdated(PoolId _poolId, FeeDistribution _feeDistribution);

  bytes32 id (poolId);

  /// The owner / dev of the token. This is set by `PoolCreated` and is updated by when the ERC721 that
  /// is minted when `flaunch` is called is transferred.
  address creator;

  /// Uniswap V4 pool `slot0` values updated via `PoolStateUpdated`
  uint160 sqrtPriceX96;
  int24 tick;
  uint24 protocolFee;
  uint24 swapFee;
  uint128 liquidity;

  /// Information extracted from the PoolKey in `PoolCreated`
  address token0;
  address token1;
  int24 tickSpacing;

  /// If a custom fee distribution has been set by `PoolFeeDistributionUpdated` then we need to
  /// assign it here.
  FeeDistribution feeDistribution;

}
```


### PoolFees

```solidity
PoolFees {

  /// Emitted when a pool has been allocated fees on either side of the position
  event PoolFeesReceived(PoolId _poolId, uint _amount0, uint _amount1);

  bytes32 id (poolId);

  /// The amount of token0 and token1 that is currently available. The will be incremented by
  /// `PoolFeesReceived` and decremented by `PoolFeesDistributed`.
  uint ethAvailable;
  uint tokenAvailable;

  /// The amount of token0 and token1 that has been added from all time. The will be incremented
  /// by `PoolFeesReceived`.
  uint totalEthOut;
  uint totalTokenIn;

}
```


### PoolFeeDistribution

These will be collected when the pool distributes fees. This could be nice to show the ongoing yield. The
amount will always be in terms of native token equivalent (ETH / flETH).

```solidity
PoolFeeDistribution {

  event PoolFeesDistributed(PoolId _poolId, uint _amount0);

  bytes32 id (poolId);

  uint amount;

}
```


### TokenEscrow

The held token should always be native (ETH / flETH).

```solidity
TokenEscrow {

  event Deposit(PoolId _poolId, address _payee, address _token, uint _amount);
  event Withdrawal(address _payee, address _token, uint _amount);

  // Unique identifier based on the recipient (payee) address
  bytes id (payee);

  // The address of the payee / recipient
  address payee;

  // The amount of token available. This entity will either be created by TokenEscrow.Deposit and
  // the amount value will be updated by both TokenEscrow.Deposit and TokenEscrow.Withdrawal.
  uint amount;

  // When the last deposit was made
  uint updated;
}
```


### Referrer Fee Payment

When a user receives a payment for referring another user.

```solidity
ReferrerFee {

  event ReferrerFeePaid(PoolId _poolId, address _recipient, address _token, uint _amount);

  bytes32 id (poolId);

  address recipient;

  address token;
  uint amount;

}
```


### Other Events

These are other events currently being fired, but I wasn't sure of the usefullness of them.

```solidity
/// Emitted when pool fees have been internally swapped
event PoolFeesSwapped(PoolId _poolId, bool zeroForOne, uint _amount0, uint _amount1);
```
